⟦IF⟧
	if 〈 DEFINITION¹; 〉? SIMPLEEXPR² then? EXPR 〈 else EXPR 〉?

	- (1) is scoped to the IF - this includes the condition (2), the then
	  as well as the optional else branch. The Value - if present - must be
	  a SIMPLEEXPR.
	- (2) must be of type bool. The then branch is executed when this is
	  true; If an else branch is present, it is executed iff (2) evalutes
	  to false.
	- If the else branch is omitted, the then branch must be of type void.
	  In this case, the type of the IF is also void. 
	- If the else branch is present, its type must be compatible with the
	  type of the then branch.

⟦LABEL⟧
	@IDENT

⟦BREAK⟧
	break LABEL¹? 〈 ; | SIMPLEEXPR² 〉

	- (1) must refer to a construct that contains the BREAK in its scope.
	  If there is more than one such construct, then (1) refers to the
	  innermost one.
	- The scope of a construct is defined as
		- FOR: The Loop Body as well as the Finally Body
		- BLOCK: The Block Body
	- (1) may be omitted iff the BREAK is contained in at least one FOR. In
	this case, the BREAK refers to the innermost FOR that contains it in its
	loop body.
	- (2) must be a VALUEEXPR
	- BREAK is considered a VALUEEXPR iff
		- (1) is omitted and the surrounding construct is a FOR or
		- (1) refers to the immediately surrounding construct.

⟦FOR⟧
	LABEL? for 〈 〈 DEFINITION¹; 〉? SIMPLEEXPR² 〈 ; SIMPLEEXPR³ 〉? 〉⁴? do⁵? EXPR⁶ 〈 finally EXPR 〉⁷?

	- (1) is scoped to the FOR - this includes the condition (2), the
	  increment (3), the loop body as well as the finally EXPR. The Value -
	  if present - must be a SIMPLEEXPR.
	- (2) must be of type bool. This is evaluated before executing the loop
	  body (6). If it evaluates to false, then execution continues after
	  (6), i.e. at the optionally present finally, or otherwise at the next
	  EXPR. Otherwise, (6) is executed, followed by (3), after which this
	  process is repeated.
	- (3) must - if present - either be an ASSIGNMENT or a CALL.
	- (4) not being present is semantically equivalent to (2) being "true",
	  and (1) and (3) being omitted.
	- (5) is optional iff
	      - (6) is not a SIMPLEEXPR
	      - (2) is present
	- (6) may can contain BREAKs. If a BREAK with no LABEL is reached
	  during execution, execution continues after the FOR. If a BREAK with
	  a LABEL is reached, execution continues after the construct marked by
	  that LABEL.
	- All LABELs that reference the FOR must have compatible types.
	- (7) - if present - is executed as soon as (2) evaluates to false;
	  that is, (7) is executed iff execution leaves the FOR loop via the
	  loop header and not a break.
	- In case (2) is omitted, (7) may not be present - this is a direct
	  consequence of (7) only being executed when (2) evaluates to false.
	- The type of (7) must be compatible with the types of all BREAKs
	  referencing the FOR.
	- In case FOR is not referenced by any non-void BREAKs, its type is
	  void. Otherwise, FOR's type is the common type of (7) and the BREAKs
	  referencing it.
	  In case (7) is omitted, it is semantically equivalent to 'finally
	  unreachable'.

⟦FOREACH⟧
	LABEL? for IDENT¹ 〈 , IDENT² 〉? <- SIMPLEEXPR³ do⁴? EXPR⁵ 〈 finally EXPR 〉⁶?

	- (1) and (2) are effectively definitions, as outlined below
	- (3) must implement Iter.
	- (6) is executed equivalently to (7) in FOR. The same rules regarding
	  BREAK also apply.
	- for a, b <- c do
		〈...〉

	is semantically equivalent to

	for it : mut = c; !is_empty(it); advance(it) do {
		curr := get_curr(it)
		a := value(curr)
		〈 b := index(curr) 〉?
		〈...〉
	}

⟦SWITCH⟧
	switch 〈 DEFINITION¹; 〉? SIMPLEEXPR² 〈 case SIMPLEEXPR³ => EXPR⁴ 〉* 〈 case => EXPR⁴ 〉⁵?

	- (1) is scoped to the SWITCH - this includes the switched EXPR (2),
	  the case patterns (3) and the case bodies (4).
	- (2) must not be void.
	- The types of all (3)s must be compatible with (2). Their values must
	  all be constant.
	- All (4)s must have a common type. The type of the SWITCH is that
	  common type.
	- In case (5) is not present, the (3)s must exhaustively list all
	  values the switched-upon type may have (e.g. 'true' and 'false' for a
	  bool).
	- Only the (4) with a (3) matching the value of (2) is executed. In
	  case no such case exists, (5) is executed (as outlined above, (5) is
	  always present in this case). 

⟦BLOCK⟧
	LABEL? { EXPR* }

⟦DEFINITION⟧
	IDENT¹ 〈 : | :: 〉² SIMPLEEXPR?³ = EXPR⁴?

	- (1) is the name by which the defined variable or constant can be
	  referenced.
	- (3) is the optional type of the defined variable. It must evaluate to
	  a type - including proc, func and trait - or a TRAIT.
	- (4) is the optional initial value of the defined variable. If (3) is
	  present, the type of (4) must be compatible with (3). Otherwise, the
	  type of the defined variable is deduced from (4). In case the type of
	  (4) is ambigouous, this is an error.
	- It is not possible to omit both (3) and (4). At least one of them
	  must be present. 

⟦UNARYOP⟧
	〈 ~ | ! | $ | & | - | try | * | [] | [*] | [...] | ... 〉 SIMPLEEXPR

⟦BINARYOP⟧
	SIMPLEEXPR 〈 〈 + | - | * | / | % | & | | | ^ | << | >> | && | || | < | <= | == | != | > | >= | . 〉 SIMPLEEXPR | [SIMPLEEXPR] 〉

⟦ASSIGNMENT⟧
	SIMPLEEXPR 〈 = | += | -= | *= | /= | %= | &= | |= | ^= | <<= | >>= 〉 EXPR

⟦RETURN⟧
	return 〈 ;¹ | EXPR² 〉

	- (1) is only allowed inside the bodies of funcs/procs that return
	  void. Note that even in this case, (2) can be used instead, as long
	  as it evaluates to void.
	- (2) must be of the same type as the func/proc that the RETURN is
	  contained in

⟦SIMPLEEXPR⟧
	IDENT | LITERAL | UNARYOP | BINARYOP | CALL | CATCH | SIGNATURE | BREAK | RETURN

⟦IDENT⟧
	〈 a - z | A - Z | _ 〉 〈 a - z | A - Z | _ | 0 - 9 〉*

⟦LITERAL⟧
	INTEGERLITERAL | FLOATLITERAL | STRINGLITERAL | CHARLITERAL

⟦INTEGERLITERAL⟧
	HEXINTEGERLIT | DECINTEGERLIT | OCTINTEGERLIT | BININTEGERLIT

⟦HEXINTEGERLIT⟧
	0〈 x | X 〉 〈 0 - 9 | a - f | A - F 〉+

⟦DECINTEGERLIT⟧
	〈 0 - 9 〉+

⟦OCTINTEGERLIT⟧
	0〈 o | O 〉 〈 0 - 7 〉+

⟦BININTEGERLIT⟧
	0〈 b | B 〉 〈 0 - 1 〉+

⟦FLOATLITERAL⟧

⟦STRINGLITERAL⟧
	" 〈〈 Any character other than " not preceded by \ 〉〉* "

⟦CHARLITERAL⟧
	'  〈〈 Any character other than ' not preceded by \ 〉〉* '

⟦UNARYOP⟧
	〈 ~ | ! | & | - | try | * | [] | [*] | [...] | ... | ? | [?] 〉 SIMPLEEXPR | SIMPLEEXPR .*

⟦BINARYOP⟧
	SIMPLEEXPR 〈 + | - | * | / | % | & | | | ^ | << | >> | && | || < | <= | > | >= | != | == | . 〉 SIMPLEEXPR | SIMPLEEXPR [ SIMPLEEXPR ]

⟦CALL⟧
	SIMPLEEXPR ( 〈 SIMPLEEXPR 〈 , SIMPLEEXPR 〉* 〉? )

⟦CATCH⟧
	SIMPLEEXPR catch 〈 IDENT -> 〉? SIMPLEEXPR

⟦SIGNATURE⟧
	〈 proc | func 〉 〈 ( 〈 DEFINITION 〈 , DEFINITION 〉* 〉? ) 〉? 〈 -> SIMPLEEXPR 〉? | trait ( 〈 DEFINITION 〈 , DEFINITION 〉* 〉? )

⟦ASSIGNMENT⟧
	SIMPLEEXPR 〈 = | += | -= | *= | /= | %= | &= | |= | ^= | <<= | >>= 〉 EXPR

⟦EXPR⟧
	IF | FOR | FOREACH | SWITCH | BLOCK | DEFINITION | ASSIGNMENT | SIMPLEEXPR



⟦BUILTIN-TYPE⟧
	- Builtin types are

	- u8, u16, u32, u64, u128
	  Unsigned integers of the stated bit-width.

	- i8, i16, i32, i64, i128
	  Signed two's complement integers of the stated bit-width.

	- f32, f64
	  IEEE754 single and double precision floating point numbers
	  respectively.

	- bool
	  boolean, with the two possible values true and false. When stored in
	  memory, 8 bits wide.

	- *T
	  Pointer to T - with T being any type. Only references a single T and
	  does not support pointer arithmetic.

	- []T
	  Slice of Ts - with T being any type. Represented as a pointer and a
	  length.

	- [n]T
	  Array of n Ts - with n being a compile-time constant integer, and T
	  being any type. Represented as n Ts stored consecutively, with a
	  stride equal to strideof(T).

	- [*]T
	  Pointer to any number of Ts - with T being any type. Represented
	  equally to *T, but allows indexing, just like a Slice. 

	- [...]T
	  Tail Array of Ts - with T being any type not containing a Tail Array.
	  Can only be used as the last member of a type in memory order. This
	  does not count against the sizeof and strideof of a type containing
	  it.

	- &T
	  A reference to T - with T being any type. Can only be used as a
	  func or proc argument. For further information, see FUNCTION

	- Type
	  Custom type. See CUSTOM-TYPE for further information.

	- 〈 pub 〉? 〈 global 〉? 〈 mut 〉? t : T 〈 = v 〉?
	  Member. See CUSTOM-TYPE for further information.

⟦CUSTOM-TYPE⟧
	A custom type is represented by an instance of Type. The API for
	creating such an instance is:

	(1) create :: func -> PartialType

	(2) add_member :: func(t : &mut PartialType, T : Type, ident : []u8, value : T, offset : isz, visibility : Enum(Public, Private), mutablity : Enum(Mutable, Immutable, Comptime), storage : Enum(Default, Global))
	    add_member :: func(t : &mut PartialType, m : Member, offset : isz)

	    add_impl :: func(t : &mut PartialType, T : Trait, members : ...Any)

	(3) create :: func(t : PartialType, alignment : usz, size : usz) -> Type

	First, a PartialType is created using (1). This is basically an empty
	type that can be refined using (2). As soon as all desired members have
	been added, the type can be finalized using (3). This 'locks' the
	type to its current members and makes it actually usable as a type.

	There are a few standard functions that create types using simplified
	syntax. These take Member declarations and return a finished Type.

	Struct :: func(members :: ...Member) -> Type
	  Consecutive storage for multiple named members.

	Union :: func(members :: ...Member) -> Type
	  Overlapping storage for multiple named members. Which one of these is
	  'valid' is not tracked internally.

	Enum :: func(T :: Type, enumerants :: ...NamedValue(T)) -> Type
	  Collection of named constants of a distinct type, with T being that
	  type's underlying type. T must implement the Ordered trait. The
	  returned type implements the Enumeration trait.

	CStruct :: func(members :: ...Member) -> Type
	  Similar to Struct, but obeys the layout rules of a C struct. Intended
	  for simplified interop with C code.

⟦PROC⟧
	A proc - short for procedure - is a callable unit of code. A proc is defined as

	〈 noreturn 〉?¹ 〈 callconv ( IDENT ) 〉?² proc 〈 ( 〈 DEFINITION 〈, DEFINITION 〉* 〉?³ ) 〉? 〈 -> SIMPLEEXPR 〉?⁴ 〈 with ( SIMPLEEXPR 〈 , SIMPLEEXPR 〉* ) 〉?⁵

	- (1) indicates that control does not return from the procedure. This
	  is e.g. the case for a procedure that transfers control to an entry
	  point or one that exits the program. It is not an error to omit this
	  annotation on a procedure that may not return control. It is however
	  an error to apply it to a procedure that may return control.
	- (2) indicates the calling convention of the procedure. If this is
	  omitted, the compiler is permitted to choose an arbitrary calling
	  convention.
	- (3) is the list of arguments the procedure takes, given in the usual
	  DEFINITION syntax. Note that types used here may be references -
	  indicated by a leading '&'.
	- (4) is the return type of the procedure and must evaluate to a type.
	  Omitting this is semantically equivalent to '-> void'.
	- (5) is a comma-separated list of TRAITs references that can be used to
	  constrain any type parameters in (4). Passing a type to (4) that does not
	  satisfy one of the constraints it is bound to is a compile time error.

	A proc like the above is used like any other type, e.g.

		square :: proc(x : i64) -> i64 = x * x

	with the definition's value being used computed based on the parameters
	passed to the proc. Note that just like any other type, a proc can also be
	used as a type parameter:

		apply :: proc(p :: proc(x : i64) -> i64, x : i64) -> i64 = p(x)

	To indicate that a PROC is defined in an external library and needs to be
	imported, the body needs to be set to the 'external' keyword. The same
	applies to FUNCs.

⟦FUNC⟧
	A func - short for function - is mostly equivalent to a procedure and
	defined as

	〈 callconv ( IDENT ) 〉? func 〈 ( 〈 DEFINITION 〈, DEFINITION 〉* 〉? ) 〉? 〈 -> SIMPLEEXPR 〉? 〈 with ( SIMPLEEXPR 〈 , SIMPLEEXPR 〉* ) 〉?

	The difference to PROC is that the body of
	a FUNC may only access compile time constants, its parameters and anything
	reachable through them, and may only call other FUNCs or noreturn PROCs.
	In other words, this means that a FUNC taking only immutable arguments is a
	pure function.

⟦TRAIT⟧
	Traits define interfaces that make types usable interchangeably by generic
	code.

	IDENT¹ :: trait 〈 ( 〈 DEFINITION 〈, DEFINITION 〉* 〉?² ) 〉? = BLOCK³

	- (1) is the name by which the trait can be referenced.
	- (2) is the list of types the trait is defined over. These must be
	  compile-time constants of type Type or other TRAITs.
	- (3) may only contain DEFINITIONs. These must be compile-time
	  constants and may use the definitions from (2).



⁰¹²³⁴⁵⁶⁷⁸⁹
