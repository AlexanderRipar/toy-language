MaybeError ::= trait(S :: Type, V :: Type, E :: Type)
{
	is_ok :: proc(s : &S) -> bool

	unwrap_value :: proc(s : S) -> V

	unwrap_error :: proc(s : S) -> E

	create :: proc(v: V) -> S

	create :: proc(e: E) -> S
}

ErrorCode ::= trait(S :: Type)
{
	is_ok :: proc(s : &S) -> bool

	short_description :: proc(s : &S) -> Stringy

	long_description :: proc(s : &S) -> Stringy
}

Error ::= struct
{
	error_type_id : u32

	error : u32
}

impl To(ErrorCode, Error)
{
	to :: proc(e :: ErrorCode) -> Error =
	{
		assert(sizeof(e) <= 4)

		id ::= comptime_counter(Error, typeof(e))

	}
}

Result :: proc(V :: Type) -> Type =
{
	return struct
	{
		error :: Error

		value :: V

		pub impl MaybeError(self, V, Error)
		{
			is_ok :: proc(s : &self) -> bool =
				is_ok(error)

			unwrap_value :: proc(s : self) =
				if is_ok(s) return value
				else undefined

			unwrap_error :: proc(s : self) =
				if !is_ok(s) return error
				else undefined
		}
	}
}

HResult ::= enum(i32)
{
	S_OK		= 0x00000000
	E_ABORT		= 0x80004004
	E_ACCESSDENIED	= 0x80070005
	E_FAIL		= 0x80004005
	E_HANDLE	= 0x80070006
	E_INVALIDARG	= 0x80070057
	E_NOINTERFACE	= 0x80004002
	E_NOTIMPL	= 0x80004001
	E_OUTOFMEMORY	= 0x8007000E
	E_POINTER	= 0x80004003
	E_UNEXPECTED	= 0x8000FFFF
}

impl ErrorCode(HResult)
{
	is_ok :: proc(s : &self) -> bool =
		s == S_OK

	short_description :: proc(s : &self) -> []char8 =
		enumerant_name(s)

	long_description :: proc(s : &self) -> Result(String) =
		format_hresult(s)
}

format_hresult :: proc(hr : &HResult) -> Result(String) =
{
	win32 ::= import("Windows.h")

	buf : mut [*]char8

	rst := win32.FormatMessage(
		  FORMAT_MESSAGE_ALLOCATE_BUFFER
		| FORMAT_MESSAGE_FROM_SYSTEM
		| FORMAT_MESSAGE_IGNORE_INSERTS,
		null,
		to(hr, DWORD),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		&buf,
		0,
		null)

	if rst == 0
		return create(to(GetLastError(), HResult))

	defer win32.LocalFree(buf)

	return from_buffer(buf, to(rst))
}






















/*
EXIT_SUCCESS :: i32 = 0
EXIT_FAILURE :: i32 = 1

alt_guessing_game :: proc -> Result(void) =
{
	con ::= std.console

	seed := try std.os.get_process_id()

	rng : std.rand.Fnv1a = create(seed)

	for
	{
		number : u32 = next(rng, 10) + 1

		con.print("Guess the number (between 1 and 10)\n")

		for
		{
			guess := try con.read_line()

			guess : u32 = try std.parse(guess)

			if guess == number
			{
				con.print("{} is correct! Want to go again? [Y|N]\n", guess)

				for do
					if cont := try con.read_line(); streq(cont, "Y")
						break
					else if streq(cont, "N")
						return create(create())
					else
						con.print("Please specify either 'Y' or 'N' ('{}' specified)\n", cont)
			}
		}
	}
}

main :: proc -> i32 =
{
	alt_guessing_game() catch return EXIT_FAILURE

	return EXIT_SUCCESS
}
*/
