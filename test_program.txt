my_slice : []i32

my_array : [5 * 2]i32

proc_to_proc_ref ::= proc() -> &proc(i : i32) -> i32
	return
		proc(i : i32) -> i32
		{
			return i * i
		}

X ::= struct
{
	tag : enum
	{
		x
		y
	}

	union
	{
		x : u32

		y : f32
	}
}

Result ::= proc(Success :: &type, Failure :: &type) -> type
{
	Failure ::= implements(Failure, ErrorCode)

	return struct
	{
		success : Success

		failure : Failure

		impl MaybeError(Self)
		{
			is_ok ::= proc(self : &Self) -> bool
				return is_ok(failure)
		}
	}
}

MaybeError ::= trait(T :: &type)
{
	is_ok ::= proc(t : &T) -> bool undef
}

IS_DEBUG ::= false

debug_print ::=
	if IS_DEBUG
		yield proc(fmt : &Slice(char8), args : &Vararg(anytype)) -> bool return print(fmt, args)
	else
		yield proc(fmt : &Slice(char8), args : &Vararg(anytype)) -> bool return true

debug_info ::=
	if IS_DEBUG
		yield struct{ line : u32 }
	else
		yield struct{}

print ::= proc(fmt : &Slice(char8), args : &Vararg(anytype)) -> bool
{
	formatters ::= Array(size(args), Formatter)

	for arg, idx <- args do
	{
		at(formatters, idx) = create(arg)
	}

	return true
}

Formatter :: struct
{
	data : &void

	fmt_proc : &proc(data : &void, buf : & Buffer) -> bool
}

ErrorCode ::= trait(T : type)
{
	is_ok ::= proc(t : &T) -> bool undef
}

WinRst ::= proc(Success : &type) -> type
	return Result(Success, HResult)

HResult ::= enum
{
	// snip
}

EXIT_SUCCESS :: i32 = 0

EXIT_FAILURE :: i32 = 1
