y[3]

/*
let add = func(x: uint, y: uint) -> uint = x + y

let x = [n]T

let x = [...](y[0 + [T.x]s] + 1)

let y = f(.x = x, y = y + 3)

// let parens = ((1 + 1) * 2 + x)

// let array_index = x[0]

// let complex_array_index = ((x[(0 + 1)]) + (3)) * 4

// let array_type = [5]T

// let empty_call = f()

// let single_arg_call = f(1)

let x = (1 + 2) * 3

let two_arg_call = f(1, 2, 3)

let x = f(1)

let f = switch x where let x = 1
    case 1 -> { "x" }
    case 2 -> "y"

for x < 10, x += 1 where mut x = 0, let y : u32 = 3 do
    bla()

let f = func(let x : u32, let y : u32) -> u32 = x + y

let g = func(x : u32) = x * 2

for x, y <- v where
    v = get_vs()
do
    f(x, x * 2)

let y = try f()

let z = f() catch v -> {
    log(v)

    0
}

for i < 10, i += 1 where mut i = 0
{

}




if x.y where
    x = get_something(),
    y = 3
then
    bla(x)


for i < 100 {

}

use pub mut global my_string_variable = "hello world"

my_string_variable = "Another string :o" // does not compile

let Vector2 = Struct(
    let x: u32,

    let y: u32
)

let Vector3 = Struct(
    use v2: Vector2,

    let z: u32
)

let TU = Struct(

    let tag: u32,

    use u: Union(
        let a: u32,

        let b: *byte
    )
)

let v : Vector3 = .{ .x = 1, .y = 2, .z = 3 }

v.x

use code = import("path/to/file")

x = 3

// in other file:

pub mut x = 5
*/