#ifndef MINOS_HPP_INCLUDE_GUARD
#define MINOS_HPP_INCLUDE_GUARD

#include "common.hpp"
#include "range.hpp"

namespace minos
{
	#ifdef _WIN32
		#define THREAD_PROC __stdcall
	#else
		#define THREAD_PROC
	#endif

	using thread_proc = u32 (THREAD_PROC *) (void* param);

	static constexpr u32 MAX_PATH_CHARS = 32767;

	namespace timeout
	{
		static constexpr u32 INFINITE = 0xFFFF'FFFF;
	}

	static constexpr u32 SETTABLE_FILE_FLAGS = 0x0020  // FILE_ATTRIBUTE_ARCHIVE
	                                         | 0x0002  // FILE_ATTRIBUTE_HIDDEN
	                                         | 0x0080  // FILE_ATTRIBUTE_NORMAL
	                                         | 0x2000  // FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
	                                         | 0x1000  // FILE_ATTRIBUTE_OFFLINE
	                                         | 0x0001  // FILE_ATTRIBUTE_READONLY
	                                         | 0x0004  // FILE_ATTRIBUTE_SYSTEM
	                                         | 0x0100; // FILE_ATTRIBUTE_TEMPORARY

	enum class Access
	{
		None    = 0x00,
		Read    = 0x01,
		Write   = 0x02,
		Execute = 0x04,
	};

	static inline Access operator|(Access lhs, Access rhs) noexcept
	{
		return static_cast<Access>(static_cast<u32>(lhs) | static_cast<u32>(rhs));
	}

	static inline Access operator&(Access lhs, Access rhs) noexcept
	{
		return static_cast<Access>(static_cast<u32>(lhs) & static_cast<u32>(rhs));
	}

	enum class ExistsMode
	{
		Fail,
		Open,
		OpenDirectory,
		Truncate,
	};

	enum class NewMode
	{
		Fail,
		Create,
	};

	enum class AccessPattern
	{
		Sequential,
		RandomAccess,
		Unbuffered,
	};

	enum class DirectoryEnumerationStatus
	{
		Ok,
		NoMoreFiles,
		Error,
	};

	enum class FileInfoMask
	{
		None             = 0x00,
		CreationTime     = 0x02,
		LastModifiedTime = 0x04,
		LastAccessTime   = 0x08,
	};

	static inline FileInfoMask operator|(FileInfoMask lhs, FileInfoMask rhs) noexcept
	{
		return static_cast<FileInfoMask>(static_cast<u32>(lhs) | static_cast<u32>(rhs));
	}

	static inline FileInfoMask operator&(FileInfoMask lhs, FileInfoMask rhs) noexcept
	{
		return static_cast<FileInfoMask>(static_cast<u32>(lhs) & static_cast<u32>(rhs));
	}

	struct ThreadHandle
	{
		void* m_rep;
	};

	struct FileHandle
	{
		void* m_rep;
	};

	struct EventHandle
	{
		void* m_rep;
	};

	struct CompletionHandle
	{
		void* m_rep;
	};

	struct ProcessHandle
	{
		void* m_rep;
	};

	struct ShmHandle
	{
		void* m_rep;
	};

	struct SemaphoreHandle
	{
		void* m_rep;
	};

	struct DirectoryEnumerationHandle
	{
		void* m_rep;
	};

	struct GenericHandle
	{
		void* m_rep;

		GenericHandle(ProcessHandle h) noexcept : m_rep{ h.m_rep } {}

		GenericHandle(EventHandle h) noexcept : m_rep{ h.m_rep } {}

		GenericHandle(FileHandle h) noexcept : m_rep{ h.m_rep } {}

		GenericHandle(ShmHandle h) noexcept : m_rep{ h.m_rep } {}

		GenericHandle(SemaphoreHandle h) noexcept : m_rep{ h.m_rep } {}
	};
	
	struct FileIdentity
	{
		u32 volume_serial;

		u64 index;
	};

	struct FileInfo
	{
		FileIdentity identity;

		u64 bytes;

		u64 creation_time;

		u64 last_modified_time;

		u64 last_access_time;

		bool is_directory;
	};

	struct Overlapped
	{
		u64 reserved_0;

		u64 reserved_1;

		u64 offset;

		EventHandle event;
	};

	struct CompletionResult
	{
		u64 key;

		Overlapped* overlapped;

		u32 bytes;
	};

	struct CompletionInitializer
	{
		CompletionHandle completion;

		u64 key;
	};

	struct DirectoryEnumerationResult
	{
		u64 creation_time;

		u64 last_access_time;

		u64 last_write_time;

		u64 bytes;

		bool is_directory;

		char8 filename[260 * 3];
	};

	static constexpr u32 CACHELINE_BYTES = 64;

	void init() noexcept;

	void deinit() noexcept;

	// Returns the error code generated by the previous minos call.
	// If the last call succeeded, the result is undefined.
	// The returned error codes are specific to the underlying OS and mainly
	// intended for debugging.
	[[nodiscard]] u32 last_error() noexcept;

	// Reserves `bytes` bytes of memory, starting on an alignment of at least
	// `minos::page_bytes` bytes.
	// In case the operation succeeds, a non-null pointer to the start of the
	// reserved address space is returned. In case the reservation could not be
	// fulfilled, nullptr is returned.
	// Memory thus reserved may not be directly accessed; Instead,
	// `minos::mem_commit` must be used to make subranges of it available for
	// reading and writing.
	// The returned pointer, along with the exact number of bytes reserved must
	// be freed by a call to `minos::mem_unreserve`.
	// This function is explicitly intended for making *huge* reservations in
	// the range from giga- to even terrabytes, as it does not initially use up
	// any physical memory, instead only reserving virtual address space.
	[[nodiscard]] void* mem_reserve(u64 bytes) noexcept;

	// Makes `bytes` bytes of previously reserved memory starting from `ptr`
	// readable and writable.
	// In case the operation succeeds, `true` is returned, otherwise `false`.
	// The entire range from `ptr` to `ptr + bytes` must refer to memory
	// previously obtained from `minos::mem_reserve`.
	// Subsequent calls to `mem_commit` overlapping the committed range are
	// explicitly supported, having no effect on the overlapping portions. 
	[[nodiscard]] bool mem_commit(void* ptr, u64 bytes) noexcept;

	// Makes virtual address space previously reserved via `minos::mem_reserve`
	// available again.
	// `ptr` must exactly match the value returned from the call to
	// `mem_reserve`, and `bytes` must be exactly equal to the number of
	// reserved bytes.
	// Any calls to `minos::mem_commit` on the reserved memory in question are
	// also effectively decommitted as part of this call.
	void mem_unreserve(void* ptr, u64 bytes) noexcept;

	// Frees the physical memory allocated by a previous call to
	// `minos::mem_commit` back to the OS. The underlying memory reservation
	// however remains untouched.
	// `ptr` must be aligned to `minos::page_bytes` bytes, and `bytes` must be
	// a multiple thereof.
	void mem_decommit(void* ptr, u64 bytes) noexcept;

	// Returns the number of bytes contained in a page of memory.
	// This is guaranteed to be a power of two.
	[[nodiscard]] u32 page_bytes() noexcept;

	// Blocks the calling thread until `bytes` bytes starting at `*address`
	// are different from those starting at `*undesired` and a call to
	// `minos::address_wake_single` or `minos:.address_wake_all` occurs.
	// `bytes` must be one of 1, 2 or 4.
	// `address` must be a multiple of `bytes`.
	// This function may wake spuriously, meaning that it should be called in
	// a loop, repeating until a desired value is obtained.
	void address_wait(const void* address, const void* undesired, u32 bytes) noexcept;

	// Same as `minos::address_wait`, but aborting the wait after
	// `milliseconds` milliseconds.
	// In case the wait is aborted due to a timeout `false` is returned,
	// otherwise `true`.
	[[nodiscard]] bool address_wait_timeout(const void* address, const void* undesired, u32 bytes, u32 milliseconds) noexcept;

	// Wakes a single thread currently blocked on a call to
	// `minos::address_wait[_timeout]` on `address`.
	void address_wake_single(const void* address) noexcept;

	// Wakes all threads currently blocked on a call to
	// `minos::address_wait[_timeout]` on `address`.
	void address_wake_all(const void* address) noexcept;

	// Hint to the OS that the calling thread wants to relinquish its current
	// time slice.
	// This is mainly useful inside wait loops or similar constructs.
	// Note that busy waiting is of course not encouraged, but waiting a few
	// thousand cycles before calling into the OS can be a good idea
	// performance-wise, especially in case of short critical sections.
	void thread_yield() noexcept;

	// Ends the calling thread's process, setting its exit code to `exit_code`.
	// All other pending threads inside the process are terminated, meaning
	// that this should only serve either as a fail-fast measure, or be called
	// after all other threads have already exited.
	NORETURN void exit_process(u32 exit_code) noexcept;

	// Retrieves the number of logical processors available to the process.
	// This can be used as a guide when deciding on the number of worker
	// threads to create to utilize the available hardware while avoiding
	// thrashing in the OS scheduler.
	[[nodiscard]] u32 logical_processor_count() noexcept;

	// Creates a new OS thread running `proc`, with `param` as its argument.
	// In case the thread is successfully created, `true` is returned, `false` otherwise
	// If `thread_name` is non-empty (`thread_name.count() != 0`), the thread's
	// name is initialized to it to aid in debugging.
	// Note that depending on the OS, thread names may only be as short as 15
	// characters. In case `thread_name` exceeds this length, it is truncated.
	// If opt_out is non-null, a handle to the created thread is stored in it.
	// This handle must be freed by a call to `minos::thread_close`.
	[[nodiscard]] bool thread_create(thread_proc proc, void* param, Range<char8> thread_name, ThreadHandle* opt_out = nullptr) noexcept;

	// Closes a handle to a thread obtained from `minos::thread_create`.
	void thread_close(ThreadHandle handle) noexcept;

	void thread_wait(ThreadHandle handle, u32* opt_out_result) noexcept;

	[[nodiscard]] bool thread_wait_timeout(ThreadHandle handle, u32 milliseconds, u32* opt_out_result) noexcept;

	// Opens or creates the file referred to by `filepath`.
	//
	// `filepath` is an OS-specific path, encoded in UTF-8.
	//
	// `access` specifies how the file will be accessed. These values (apart
	// from `Access::None`) may be combined together using `|`:
	//   - `Access::None` allows only metadata reads (i.e.
	//     `minos::file_get_info`).
	//   - `Access::Read` allows read access to the file's contents.
	//   - `Access::Write` allows write access to the file's contents.
	//   - `Access::Execute` is not supported.
	//
	// `exists_mode` indicates the intended behaviour in case the file already
	// exists:
	//   - `ExistsMode::Fail` makes the function fail in case the file already
	//     exists.
	//   - `ExistsMode::Open` opens an existing file.
	//   - `ExistsMode::OpenDirectory` indicates that `filepath` refers to a
	//     directory. This mode must be used in this case.
	//   - `ExistsMode::Truncate` truncates an existing file.
	//
	// `new_mode` indicates the intended behaviour in case the file does not
	// yet exist:
	//    - `NewMode::Fail` fails if the file does not yet exist.
	//    - `NewMode::Create` creates a new empty file if it does not yet
	//      exist.
	//
	// `pattern` hints to the OS how the file will be accessed.:
	//   - `AccessPattern::Sequential` hints that the file will be accessed
	//      in large continuous ranges.
	//   - `AccessPattern::RandomAccess` hints that the file will be accessed
	//      at random locations.
	//   - `AccessPattern::Unbuffered` hints that the file access should not go
	//     through OS disk caches, instead accessing the disk directly.
	//     When this is selected, both the sizes and alignments of the buffers
	//     passed to `minos::file_read` and `minos::file_write`, as well as the
	//    `offset` in the corresponding `minos::Overlapped` structures must be
	//    multiples of `minos::page_bytes`.
	//
	// `opt_completion` contains optional information on a
	// `minos::CompletionHandle` to be associated with this file. If it is
	// non-null, the `completion` member must refer to a
	// `minos::CompletionHandle` previously initialized via
	// `minos::completion_create`. Any `minos::file_read` and
	// `minos::file_write` calls on the created `FileHandle` will become
	// asynchronous, meaning that they will return immediately without waiting
	// for the operation to complete.
	// As soon as the operation does complete, a thread waiting in
	// `minos::completion_wait` will be woken. Note that if no thread is
	// waiting at the time of completion, a thread calling
	// `minos::completion_wait` on the given `CompletionHandle` at a later time
	// will be woken.
	// 
	// `inheritable` decides whether the handle will be inherited by processes
	// created via `minos::process_create`.
	//
	// `out` receives the created `FileHandle`, which must be freed by calling
	// `minos::file_close`.
	// If `file_create` fails, the contents of `out` are undefined and must not
	// be passed to `minos::file_close`.
	[[nodiscard]] bool file_create(Range<char8> filepath, Access access, ExistsMode exists_mode, NewMode new_mode, AccessPattern pattern, const CompletionInitializer* opt_completion, bool inheritable, FileHandle* out) noexcept;

	// Closes a `minos::FileHandle` obtained from a previous call to
	// `minos::file_create`.
	void file_close(FileHandle handle) noexcept;

	[[nodiscard]] bool file_read(FileHandle handle, MutRange<byte>, u64 offset, u32* out_bytes_read) noexcept;

	[[nodiscard]] bool file_read_async(FileHandle handle, MutRange<byte> buffer, Overlapped* overlapped) noexcept;

	[[nodiscard]] bool file_write(FileHandle handle, Range<byte> buffer, u64 offset) noexcept;

	[[nodiscard]] bool file_write_async(FileHandle handle, Range<byte> buffer, Overlapped* overlapped) noexcept;

	[[nodiscard]] bool file_get_info(FileHandle handle, FileInfo* out) noexcept;

	[[nodiscard]] bool file_resize(FileHandle handle, u64 new_bytes) noexcept;

	[[nodiscard]] bool event_create(EventHandle* out) noexcept;

	void event_close(EventHandle handle) noexcept;

	void event_wake(EventHandle handle) noexcept;

	void event_wait(EventHandle handle) noexcept;

	[[nodiscard]] bool event_wait_timeout(EventHandle handle, u32 milliseconds) noexcept;

	[[nodiscard]] bool completion_create(CompletionHandle* out) noexcept;

	void completion_close(CompletionHandle handle) noexcept;

	[[nodiscard]] bool completion_wait(CompletionHandle completion, CompletionResult* out) noexcept;

	void sleep(u32 milliseconds) noexcept;

	[[nodiscard]] bool process_create(Range<char8> exe_path, Range<Range<char8>> command_line, Range<char8> working_directory, Range<GenericHandle> inherited_handles, bool inheritable, ProcessHandle* out) noexcept;

	void process_close(ProcessHandle handle) noexcept;

	void process_wait(ProcessHandle handle, u32* opt_out_result) noexcept;

	[[nodiscard]] bool process_wait_timeout(ProcessHandle handle, u32 milliseconds, u32* opt_out_result) noexcept;

	[[nodiscard]] bool shm_create(Access access, u64 bytes, ShmHandle* out) noexcept;

	void shm_close(ShmHandle handle) noexcept;

	[[nodiscard]] void* shm_reserve(ShmHandle handle, u64 offset, u64 bytes) noexcept;

	void shm_unreserve(void* address, u64 bytes) noexcept;

	[[nodiscard]] bool shm_commit(void* address, Access access, u64 bytes) noexcept;

	[[nodiscard]] bool sempahore_create(u32 initial_count, SemaphoreHandle* out) noexcept;

	void semaphore_close(SemaphoreHandle handle) noexcept;

	void semaphore_post(SemaphoreHandle handle, u32 count) noexcept;

	void semaphore_wait(SemaphoreHandle handle) noexcept;

	[[nodiscard]] bool semaphore_wait_timeout(SemaphoreHandle handle, u32 milliseconds) noexcept;

	[[nodiscard]] DirectoryEnumerationStatus directory_enumeration_create(Range<char8> directory_path, DirectoryEnumerationHandle* out, DirectoryEnumerationResult* out_first) noexcept;

	[[nodiscard]] DirectoryEnumerationStatus directory_enumeration_next(DirectoryEnumerationHandle handle, DirectoryEnumerationResult* out) noexcept;

	void directory_enumeration_close(DirectoryEnumerationHandle handle) noexcept;

	[[nodiscard]] bool directory_create(Range<char8> path) noexcept;

	[[nodiscard]] bool path_remove_file(Range<char8> path) noexcept;

	[[nodiscard]] bool path_remove_directory(Range<char8> path) noexcept;

	[[nodiscard]] bool path_is_directory(Range<char8> path) noexcept;

	[[nodiscard]] bool path_is_file(Range<char8> path) noexcept;

	[[nodiscard]] u32 working_directory(MutRange<char8> out_buf) noexcept;

	[[nodiscard]] u32 path_to_absolute(Range<char8> path, MutRange<char8> out_buf) noexcept;

	[[nodiscard]] u32 path_to_absolute_relative_to(Range<char8> path, Range<char8> base, MutRange<char8> out_buf) noexcept;

	[[nodiscard]] u32 path_to_absolute_directory(Range<char8> path, MutRange<char8> out_buf) noexcept;

	[[nodiscard]] bool path_get_info(Range<char8> path, FileInfo* out) noexcept;

	[[nodiscard]] u64 timestamp_utc() noexcept;

	[[nodiscard]] u64 timestamp_ticks_per_second() noexcept;

	[[nodiscard]] u64 exact_timestamp() noexcept;

	[[nodiscard]] u64 exact_timestamp_ticks_per_second() noexcept;
}

#endif // MINSO_HPP_INCLUDE_GUARD
